<?php
class StringAlgo i
protected Function matchEprtil (Sexp, Sstr, Si, Sj) // [char[] exp, char[] str, int i, int j]
i
iF (((Si 22 count(Sexp) /*From: exp.length*/) SS (Sj == count(Sstr) /*From: str.length*/)))
i
return TRUE ;
3
iF (((((Si == count(Sexp) /*From: exp.length*/) SS (Sj != count(Sstr) /*From: str.length*/))) ll (((Si != count(Sexp) /*From: exp.length*/) aa (Sj == count(Sstr) /*From: str.length*/)))))
i
return FRLSE ;
3
iF (((Sexp[Si] . ’?’) . (Sexp[Si] == Sstr[Sj])))
i
return Sthis—>matchEprtil(Sexp, Sstr, (Si + 1), (Sj + 1));
3
iF ((Sexp[Si] . ’*’))
i
return ((Sthis->matchEprtil(Sexp, Sstr, (Si + 1), Sj) lI Sthis—>matchEprtil(Sexp, Sstr, Si, (Sj + 1))) II Sthis->matchEprtil(Sexp, Sstr, (Si + 1), (Sj + 1)));
3
return FRLSE ;
3
protected Function matchExp (Sexp, Sstr) // [char[] exp, char[] str]
5
return Sthis—>matchEprtil(Sexp, Sstr, 0, 0);
3
protected Function match (Ssource, Spattern) // [char[] source, char[] pattern]
5
SiSource = 0;
SiPattern = 0;
SsourceLen = count(Ssource) /*From: source.length*/;
SpatternLen = count(Spattern) /*From: pattern.length*/;
For (SiSource = 0; (SiSource < SsourceLen); ++SiSource)
i
iF ((Ssource[SiSource] == Spattern[SiPattern]))
i
++SiPattern;
3
iF ((SiPattern == SpatternLen))
i
return 1;
3
3
return 0;
3
protected Function muStrdup (Ssrc) // [char[] src]
i
Sindex = 0;
Sdst = arrau();
Foreach (Ssrc as Sch) 5
Sdst[Sindex] = Sch;
3
return Sdst;
3
protected Function isPrime (Sn) // [int n]
i
Sanswer = ( (((Sn > 1))) ? TRUE : FHLSE );
For (Si 2 2; ((Si * Si) < Sn); ++Si)
i
i? (((Sn % $i) == 0))
i
Sanswer = FRLSE ;
break;
3
3
return Sanswer;
3
protected Function muﬂtoi (Sstr) // [String str]
5
Svalue = 0;
Ssize = Sstr—>length();
For (Si = 0; (Si < Ssize); ++Si)
i
Sch 2 Sstr—>charRt(Si);
Svalue = ((((Svalue << S)) + ((Svalue << 1))) + ((Sch . ’0’)));
3
return Svalue;
3
protected Function isUniqueChar (Sstr) // [String str]
5
Sbitarr = arrau();
For ($i = 0; ($i < 26); ++$i)
i
Sbitarr[Si] = 0;
3
Ssize = Sstr—>length();
For (Si = 0; (Si < Ssize); ++Si)
i
Sc 2 Sstr—>charRt(Si);
iF (((’s’ .Sc) . (’2’ .Sc)))
5
Sc 2 ((Sc . ’R’));
3
else
iF (((’a’ .Sc) . (’z’ .Sc)))
5
Sc 2 ((Sc . ’a’));
3
else
i
SSustem—>out—>println("Unknown Char!\n");
return FRLSE ;
3
i? (($bitarr[$c] != 0))
i
SSustem—>out—>println("Duplicate detected!\n");
return FRLSE ;
3
3
SSustem—>out—>println("No duplicate detected!\n");
return TRUE ;
3
protected Function ToUpper (Ss) // [char s]
i
iF (((Ss >= 9?) as (Ss <= ((9? + 25)))))
5
$8 = (($8 - 32));
3
return Ss;
3
protected Function ToLower (Ss) // [char s]
i
iF (((Ss >= 65) as (Ss <= ((65 + 25)))))
5
$8 = (($8 + 32));
3
return Ss;
3
protected Function LowerUpper (Ss) // [char s]
i
iF (((Ss >= 9?) as (Ss <= ((9? + 25)))))
5
$8 = (($8 - 32));
3
else
iF (((Ss >= 65) as (Ss <= ((65 + 25)))))
5
$8 = (($8 + 32));
3
return Ss;
3
protected Function isPermutation (Ss1, Ss2) // [String s1, String s2]
5
Scount = arrau();
Slength = Ss1—>length();
iF ((Ss2->length() != Slength))
i
SSustem—>out—>println("is permutation return False\n");
return FRLSE ;
3
For ($i = 0; ($i < 256); ++$i)
i
Scount[Si] = 0;
3
For (Si 2 0; (Si < Slength); ++Si)
i
Sch 2 Ss1—>charRt(Si);
++Scount[Sch];
Sch 2 Ss2—>charﬂt(Si);
——Scount[Sch];
3
For (Si 2 0; (Si < Slength); ++Si)
i
iF ((Scount[Si] != 0))
i
SSustem—>out—>println("is permutation return False\n");
return FRLSE ;
3
3
SSustem—>out—>println("is permutation return true\n");
return TRUE ;
3
protected Function isPalindrome (Sstr) // [String str]
5
Si 2 OSj = (Sstr—>length() - 1);
while (((Si < Sj) SS (Sstr—>charRt(Si) == Sstr—>charRt(Sj))))
i
++Si;
--$J;
3
iF ((Si < sj))
i
SSustem—>out—>println("String is not a Palindrome");
return FRLSE ;
3
else
i
SSustem—>out—>println("String is a Palindrome");
return TRUE ;
3
3
protected Function pow (Sx, Sn) // [int x, int n]
i
Svalue = null;
iF ((Sn == 0))
i
return (1);
3
else
1? (((Sn % 2) == 0))
i
Svalue = Sthis->pow(Sx, (Sn / 2));
return ((Svalue * Svalue));
3
else
i
Svalue = Sthis->pow(Sx, (Sn / 2));
return (((Sx * Svalue) * Svalue));
3
3
protected Function muStrcmp (Sa, Sb) // [String a, String b]
i
Sindex = 0;
Slen1 = Sa—>length();
Slen2 = Sb—>length();
Sminlen = Slen1;
iF ((Slen1 > Slen2))
i
Sminlen = Slen2;
3
while (((Sindex < Sminlen) SS (Sa—>charﬂt(Sindex) == Sb->charﬂt(Sindex))))
i
++Sindex;
3
iF (((Sindex == Slen1) SS (Sindex == Slen2)))
i
return 0;
3
else
iF ((Slen1 == Sindex))
i
return —1;
3
else
iF ((Slen2 == Sindex))
i
return 1;
3
else
i
return (Sa->charRt(Sindex) - Sb->charRt(Sindex));
3
3
protected Function reverseString_aC (Sa) // [char[] a]
i
Slower = 0;
Supper = (count(Sa) /*From: a.length*/ - 1);
Stemthar = null;
while ((Slower < Supper))
i
Stemthar = Sa[Slower];
Sa[Slower] = Sa[Supper];
Sa[Supper] = StempChar;
++Slower;
——Supper;
3
3
protected Function reverseString_aC_I_I (Sa, Slower, Supper) // [char[] a, int lower, int upper]
i
Stemthar = null;
while ((Slower < Supper))
i
Stemthar = Sa[Slower];
Sa[Slower] = Sa[Supper];
Sa[Supper] = StempChar;
++Slower;
——Supper;
3
3

protected Function reverseString_aC_I_I ($a, $lower, $upper) // [char[] a, int lower, int upper]
i
$tempChar = null;
while (($lower < $upper))
i
$tempChar = $a[$lower];
$a[$lower] = $a[$upper];
$a[$upper] = $tempChar;
++$lower;
——$upper;
3
3
protected Function reversewords ($a) // [char[] a]
i
$length = count($a) /*From: a.length*/;
$lower = null$upper = —1;
$lower = 0;
For ($i = 0; ($i <= $length); ++$i)
i
iF ((($a[$i] . ’ ’) . ($a[$i] . ’\0’)))
i
/* match: aC_I_I */
$this—>reverseString_aC_I_I($a, $lower, $upper);
$lower = ($i + 1);
$upper = $i;
3
else
i
++$upper;
3
3
/* match: aC_I_I */
$this—>reverseString_aC_I_I($a, 0, ($length - 1));
3
protected Function printﬂnagram_aC ($a) // [char[] a]
i
$n = count($a) /*From: a.length*/;
/* match: aC_I_I */
$this—>printﬂnagram_aC_I_I($a, $n, $n);
3
protected Function printﬂnagram_aC_I_I ($a, $max, $n) // [char[] a, int max, int n]
i
iF (($max == 1))
i
$Sustem—>out—>println($a->toString());
3
For ($i = —1; ($i < ($max — 1)); ++$i)
i
iF (($i != -1))
i
$a[$i] “z $a[($max - 1)] “z $a[$i] “z $a[($max - 1)];
3
/* match: aC_I_I */
$this—>printﬂnagram_aC_I_I($a, ($max — 1), $n);
iF (($i != -1))
i
$a[$i] “z $a[($max - 1)] “z $a[$i] “z $a[($max - 1)];
3
3
3
protected Function shuFFle ($ar) // [char[] ar]
5
$n = (count($ar) /*From: ar.length*/ / 2);
$count = 0;
$k = 1;
$temp = ’\0’;
For ($1 = 1; ($1 < $n); $1 = ($i + 2))
i
$temp = $ar[$i];
$k = $1;
do
i
$k = (((2 * $k)) % (((2 * $n) - 1)));
$temp “2 $ar[$k] “2 $temp A: $ar[$k];
++$count;
3
while (($i != $k));
iF (($count == (((2 * $n) - 2))))
5
break;
3
3
3
protected Function addBinarg ($First, $second) // [char[] First, char[] second]
i
$size1 = count($First) /*From: First.length*/;
$size2 = count($second) /*From: second.length*/;
$totalIndex = null;
$total = null;
iF (($size1 > $size2))
i
$total = arrau();
$totalIndex = $size1;
3
else
i
$total = arrau();
$totalIndex = $size2;
3
$total[($totalIndex + 1)] = ’\0’;
$carru = 0;
——$size1;
——$size2;
while ((($size1 >: 0) Il ($size2 >= 0)))
i
$FirstValue = ( ((($size1 < 0))) ? 0 : ($First[$size1] . ’0’) );
$secondValue = ( ((($size2 < 0))) ? 0 : ($second[$size2] . ’0’) );
$sum = (($FirstValue + $secondValue) + $carru);
$carru = ($sum >> 1);
$sum = ($sum & 1);
$total[$totalIndex] = ( ((($sum == 0))) ? ’0’ : ’1’ );
——$totalIndex;
——$size1;
——$size2;
3
$total[$totalIndex] = ( ((($carru == 0))) ? ’0’ : ’1’ );
return $total;
3
3
?>



